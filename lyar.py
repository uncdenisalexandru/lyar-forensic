import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import re
import os
import threading
import datetime
import sqlite3
import matplotlib.pyplot as plt
import speech_recognition as sr
from fpdf import FPDF
from textblob import TextBlob


# ==========================================
# 0. DATABASE MANAGER
# ==========================================
class HistoryManager:
    def __init__(self, db_name="history.db"):
        self.conn = sqlite3.connect(db_name, check_same_thread=False)
        self.cursor = self.conn.cursor()
        self._create_table()

    def _create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS analyses (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT,
                filename TEXT,
                risk_score INTEGER,
                verdict TEXT,
                preview_text TEXT,
                full_text TEXT
            )
        ''')
        self.conn.commit()

    def save_analysis(self, filename, risk_score, verdict, full_text):
        preview = full_text[:100].replace('\n', ' ') + "..."
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.cursor.execute('''
            INSERT INTO analyses (timestamp, filename, risk_score, verdict, preview_text, full_text)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (timestamp, filename, risk_score, verdict, preview, full_text))
        self.conn.commit()
        return self.cursor.lastrowid

    def delete_entry(self, entry_id):
        self.cursor.execute("DELETE FROM analyses WHERE id=?", (entry_id,))
        self.conn.commit()
        self._check_reset()

    def clear_all(self):
        self.cursor.execute("DELETE FROM analyses")
        self.conn.commit()
        self._check_reset()

    def _check_reset(self):
        self.cursor.execute("SELECT COUNT(*) FROM analyses")
        count = self.cursor.fetchone()[0]
        if count == 0:
            self.cursor.execute("DELETE FROM sqlite_sequence WHERE name='analyses'")
            self.conn.commit()

    def get_entry_details(self, entry_id):
        self.cursor.execute("SELECT full_text, filename, risk_score, verdict FROM analyses WHERE id=?", (entry_id,))
        return self.cursor.fetchone()

    def get_all(self):
        self.cursor.execute(
            "SELECT id, timestamp, filename, risk_score, verdict, preview_text FROM analyses ORDER BY id DESC")
        return self.cursor.fetchall()

    def search(self, query):
        q = f"%{query}%"
        self.cursor.execute(
            "SELECT id, timestamp, filename, risk_score, verdict, preview_text FROM analyses WHERE filename LIKE ? OR preview_text LIKE ? OR timestamp LIKE ?",
            (q, q, q))
        return self.cursor.fetchall()


# ==========================================
# 1. ENGINE PDF
# ==========================================
class PoliceReportPDF(FPDF):
    def header(self):
        self.set_font('Courier', 'B', 16)
        self.cell(0, 10, 'LYAR FORENSIC INTELLIGENCE', 0, 1, 'C')
        self.set_font('Courier', '', 10)
        self.cell(0, 5, 'LINGUISTIC ANALYSIS DIVISION', 0, 1, 'C')
        self.ln(5)
        self.line(10, 25, 200, 25)
        self.line(10, 26, 200, 26)
        self.ln(10)

    def footer(self):
        self.set_y(-15)
        self.set_font('Courier', 'I', 8)
        self.cell(0, 10, f'Page {self.page_no()} | CONFIDENTIAL | Generated by LYAR System', 0, 0, 'C')

    def chapter_title(self, label, font_family='Courier'):
        style = 'B' if font_family == 'Courier' else ''
        self.set_font(font_family, style, 12)
        self.set_fill_color(230, 230, 230)
        self.cell(0, 8, label, 1, 1, 'L', fill=True)
        self.ln(4)


# ==========================================
# 2. ENGINE ANALYZER (No NER)
# ==========================================
class ForensicAnalyzer:
    def __init__(self, lang='ro'):
        self.lang = lang
        self.lists = {}
        self.baselines = {}
        self.ui = {}
        self.ro_sentiment = {}

        if lang == 'ro':
            self._setup_romanian()
        else:
            self._setup_english()
        self._setup_ro_sentiment_dict()

    def set_language(self, lang):
        self.lang = lang
        if lang == 'ro':
            self._setup_romanian()
        else:
            self._setup_english()

    def _setup_english(self):
        self.lists = {
            'pronouns': ['i', 'me', 'my', 'mine', 'myself', "i'm", "i've", "i'd", "i'll", 'am'],
            'hedges': ['probably', 'maybe', 'perhaps', 'possibly', 'potentially', 'it seems', 'it appears', 'i think',
                       'i believe', 'i guess', 'kind of', 'sort of'],
            'fillers': ['uh', 'um', 'er', 'ah', 'well', 'so', 'actually', 'literally', 'you know', 'i mean', 'like'],
            'qualifiers': ['honestly', 'frankly', 'truthfully', 'to be honest', 'i swear', 'believe me', 'obviously',
                           'clearly'],
            'time_leaps': ['then', 'next', 'afterward', 'later', 'suddenly', 'all of a sudden', 'eventually', 'finally']
        }
        self.baselines = {'pronouns': 3.5, 'hedges': 2.0, 'time_leaps': 4.0, 'qualifiers': 0.5, 'fillers': 2.5}
        self.ui = {
            'conclusions': ["HIGH RISK", "MODERATE RISK", "LOW RISK"],
            'labels': {'p_den': 'Pronouns', 'h_den': 'Hedges', 't_den': 'Time Leaps', 'q_den': 'Qualifiers',
                       'f_den': 'Fillers'},
            'sent_labels': ["NEGATIVE", "NEUTRAL", "POSITIVE"]
        }

    def _setup_romanian(self):
        self.lists = {
            'pronouns': ['eu', 'mine', 'mÄƒ', 'm-', '-mÄƒ', 'mie', 'Ã®mi', 'mi', 'mi-', '-mi', 'meu', 'mea',
                         'subsemnatul'],
            'hedges': ['probabil', 'poate', 'posibil', 'pare cÄƒ', 'cred', 'presupun', 'bÄƒnuiesc', 'cam', 'oarecum',
                       'parcÄƒ'],
            'fillers': ['ÄƒÄƒ', 'Ã®Ã®', 'mm', 'pÄƒi', 'deci', 'na', 'È™tii', 'zic', 'gen', 'adicÄƒ', 'mÄƒ rog', 'Ã®n fine'],
            'qualifiers': ['sincer', 'onest', 'jur', 'pe bune', 'serios', 'evident', 'clar', 'crede-mÄƒ', 'garantat',
                           'cu mÃ¢na pe inimÄƒ'],
            'time_leaps': ['apoi', 'dupÄƒ', 'dupÄƒ aia', 'ulterior', 'mai tÃ¢rziu', 'brusc', 'dintr-o datÄƒ',
                           'Ã®n cele din urmÄƒ', 'pe scurt']
        }
        self.baselines = {'pronouns': 2.5, 'hedges': 2.0, 'time_leaps': 3.5, 'qualifiers': 0.5, 'fillers': 2.0}
        self.ui = {
            'conclusions': ["RISC RIDICAT", "RISC MODERAT", "RISC SCÄ‚ZUT"],
            'labels': {'p_den': 'Pronume', 'h_den': 'EzitÄƒri', 't_den': 'Salturi Temp.', 'q_den': 'JustificÄƒri',
                       'f_den': 'UmpluturÄƒ'},
            'sent_labels': ["NEGATIV", "NEUTRU", "POZITIV"]
        }

    def _setup_ro_sentiment_dict(self):
        self.ro_sentiment = {
            'pozitiv': ['bun', 'fericit', 'bucuros', 'excelent', 'super', 'iubesc', 'ador', 'mulÈ›umit', 'sigur',
                        'adevÄƒr', 'succes', 'bine', 'frumos', 'minunat'],
            'negativ': ['rÄƒu', 'trist', 'supÄƒrat', 'nervos', 'groaznic', 'urÄƒsc', 'fricÄƒ', 'tem', 'moarte', 'durere',
                        'minciunÄƒ', 'fals', 'problemÄƒ', 'greÈ™it', 'vinovat']
        }

    def _format_text(self, text):
        return re.sub(r"[^\w\s'\-ÄƒÃ¢Ã®È™È›]", '', text.lower())

    def get_metrics(self, text):
        formatted = self._format_text(text)
        words = re.findall(r"\b[\w'\-]+\b", formatted)
        total_count = len(words)
        if total_count == 0: return None
        results = {'densities': {}, 'found_words': {}}
        mapping = {'p_den': 'pronouns', 'h_den': 'hedges', 'f_den': 'fillers', 'q_den': 'qualifiers',
                   't_den': 'time_leaps'}
        for key, list_key in mapping.items():
            word_list = self.lists[list_key]
            word_list.sort(key=len, reverse=True)
            pattern = r'\b(' + '|'.join(re.escape(w) for w in word_list) + r')\b'
            matches = re.findall(pattern, formatted)
            results['densities'][key] = (len(matches) / total_count * 100)
            results['found_words'][key] = list(set(matches))
        score = 0
        d = results['densities']
        b = self.baselines
        if d['p_den'] < b['pronouns']: score += 25
        if d['h_den'] > b['hedges']: score += 15
        if d['t_den'] > b['time_leaps']: score += 20
        if d['q_den'] > b['qualifiers']: score += 30
        if d['f_den'] > b['fillers']: score += 10
        results['risk_score'] = min(score, 100)
        results['total_words'] = total_count

        # Sentiment Analysis
        sent_res = self.analyze_sentiment(text)
        results['sentiment_score'] = sent_res['score']
        results['sentiment_label'] = sent_res['label']

        return results

    def analyze_sentiment(self, text):
        if self.lang == 'en':
            blob = TextBlob(text)
            pol = blob.sentiment.polarity
        else:
            formatted = self._format_text(text)
            words = re.findall(r"\b[\w]+\b", formatted)
            score = 0
            for w in words:
                if w in self.ro_sentiment['pozitiv']:
                    score += 1
                elif w in self.ro_sentiment['negativ']:
                    score -= 1
            if len(words) > 0:
                pol = score / (len(words) * 0.1)
            else:
                pol = 0
            pol = max(-1.0, min(1.0, pol))

        if pol > 0.1:
            label = self.ui['sent_labels'][2]
        elif pol < -0.1:
            label = self.ui['sent_labels'][0]
        else:
            label = self.ui['sent_labels'][1]

        return {'score': pol, 'label': label}

    def get_conclusion(self, score):
        if score >= 70: return self.ui['conclusions'][0]
        if score >= 40: return self.ui['conclusions'][1]
        return self.ui['conclusions'][2]

    def transcribe_audio(self, path):
        r = sr.Recognizer()
        lang_code = "ro-RO" if self.lang == 'ro' else "en-US"
        try:
            with sr.AudioFile(path) as source:
                audio = r.record(source)
                return r.recognize_google(audio, language=lang_code)
        except Exception as e:
            return f"[ERROR] {str(e)}"

    def export_html(self, text, metrics, filename, case_id):
        colors = {'q_den': '#ffcccc', 't_den': '#ffd9b3', 'h_den': '#ffffcc', 'p_den': '#ccf2ff', 'f_den': '#e6ccff'}
        highlighted_html = text
        all_words = []
        for key, words in metrics['found_words'].items():
            for w in words: all_words.append((w, colors[key]))
        all_words.sort(key=lambda x: len(x[0]), reverse=True)
        for word, color in all_words:
            pattern = re.compile(rf'\b({re.escape(word)})\b', re.IGNORECASE)
            highlighted_html = pattern.sub(
                f'<span style="background-color: {color}; padding: 1px 3px; border-radius: 3px; font-weight: bold;">\\1</span>',
                highlighted_html)

        id_str = f"LYAR-{str(case_id).zfill(5)}" if case_id else "LYAR-TEMP"
        sent_color = "#27ae60"
        if "NEG" in metrics['sentiment_label']:
            sent_color = "#c0392b"
        elif "NEU" in metrics['sentiment_label']:
            sent_color = "#7f8c8d"

        html = f"""<html><head><meta charset='UTF-8'><style>body{{font-family:'Segoe UI',sans-serif;padding:40px;background:#f4f4f9;}} .container{{background:white;padding:40px;border-radius:8px;max-width:800px;margin:auto;}} h1{{border-bottom:2px solid #eee;color:#2c3e50;}} .meta{{background:#eee;padding:10px;font-family:monospace;}} .sent-box{{display:inline-block; padding:5px 10px; color:white; border-radius:4px; font-weight:bold;}}</style></head><body><div class="container"><h1>LYAR Forensic Report</h1><div class="meta">CASE ID: {id_str} | DATE: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}</div>
        <h2>Risk Score: {metrics['risk_score']} / 100 ({self.get_conclusion(metrics['risk_score'])})</h2>
        <h3>Tone Analysis: <span class="sent-box" style="background:{sent_color}">{metrics['sentiment_label']} ({metrics['sentiment_score']:.2f})</span></h3>
        <h3>Analyzed Statement:</h3><div style="background:#fafafa;padding:20px;border:1px solid #ddd;">{highlighted_html}</div></div></body></html>"""
        with open(filename, "w", encoding="utf-8") as f:
            f.write(html)

    def export_pdf(self, text, metrics, filename, case_id):
        pdf = PoliceReportPDF()
        base_dir = os.path.dirname(os.path.abspath(__file__))
        font_path = os.path.join(base_dir, 'DejaVuSans.ttf')
        unicode_font_available = False
        font_family = 'Arial'

        try:
            if os.path.exists(font_path):
                pdf.add_font('DejaVu', '', font_path, uni=True)
                pdf.add_font('DejaVu', 'B', font_path, uni=True)
                font_family = 'DejaVu'
                unicode_font_available = True
        except:
            pass

        def safe_txt(txt):
            if unicode_font_available: return txt
            replacements = {'Äƒ': 'a', 'Ã¢': 'a', 'Ã®': 'i', 'È™': 's', 'È›': 't', 'Ä‚': 'A', 'Ã‚': 'A', 'ÃŽ': 'I', 'È˜': 'S',
                            'Èš': 'T', 'â€ž': '"', 'â€': '"'}
            for k, v in replacements.items(): txt = txt.replace(k, v)
            return txt.encode('latin-1', 'replace').decode('latin-1')

        pdf.add_page()
        id_str = f"LYAR-{str(case_id).zfill(5)}" if case_id else "LYAR-TEMP"
        pdf.set_font(font_family, '', 10)
        pdf.cell(0, 5, f"DATE: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}", 0, 1)
        pdf.cell(0, 5, f"CASE ID: {id_str}", 0, 1)
        pdf.cell(0, 5, f"LANGUAGE: {self.lang.upper()}", 0, 1)
        pdf.ln(5)

        pdf.set_font(font_family, '', 14)
        pdf.cell(0, 10, f"RISK SCORE: {metrics['risk_score']} / 100", 1, 1, 'C')
        pdf.set_font(font_family, '', 12)
        pdf.cell(0, 8, f"VERDICT: {safe_txt(self.get_conclusion(metrics['risk_score']))}", 0, 1, 'C')

        pdf.ln(2)
        sent_txt = f"TONE: {metrics['sentiment_label']} (Score: {metrics['sentiment_score']:.2f})"
        pdf.set_fill_color(240, 240, 240)
        pdf.cell(0, 8, safe_txt(sent_txt), 0, 1, 'C', fill=True)
        pdf.ln(5)

        pdf.chapter_title("1. LINGUISTIC INDICATORS", font_family)
        pdf.set_font(font_family, '', 10)
        display_map = self.ui['labels']
        keys = ['p_den', 'h_den', 'q_den', 't_den', 'f_den']
        for k in keys:
            name = safe_txt(display_map.get(k, k).upper())
            val = metrics['densities'][k]
            pdf.cell(95, 7, name, 1)
            pdf.cell(95, 7, f"{val:.2f}%", 1, 1)
        pdf.ln(5)

        pdf.chapter_title("2. SUBJECT STATEMENT", font_family)
        pdf.set_font(font_family, '', 10)
        pdf.multi_cell(0, 5, safe_txt(text))
        pdf.output(filename)

    def generate_batch_chart(self, results, output_path):
        filenames = [res['filename'] for res in results]
        scores = [res['risk'] for res in results]
        colors = ['#e74c3c' if s >= 70 else '#f39c12' if s >= 40 else '#27ae60' for s in scores]
        plt.figure(figsize=(10, 5))
        plt.bar(filenames, scores, color=colors)
        plt.axhline(y=70, color='red', linestyle='--', alpha=0.5)
        plt.title("Batch Risk Analysis")
        plt.xticks(rotation=45, ha='right')
        plt.tight_layout()
        plt.savefig(output_path)
        plt.close()


# ==========================================
# 3. GUI (FRONTEND)
# ==========================================
class ForensicApp:
    def __init__(self, root):
        self.root = root
        self.root.title("LYAR - Forensic Intelligence Suite")
        self.root.geometry("1200x800")

        self.analyzer = ForensicAnalyzer('ro')
        self.db = HistoryManager()
        self.last_metrics = None
        self.last_case_id = None
        self.current_filename = "Manual_Input"

        style = ttk.Style()
        style.theme_use('clam')
        style.configure("Treeview.Heading", font=('Segoe UI', 10, 'bold'))

        header = ttk.Frame(root, padding=15)
        header.pack(fill='x')
        ttk.Label(header, text="LYAR FORENSICS", font=("Segoe UI", 18, "bold"), foreground="#2c3e50").pack(side='left')
        self.lang_var = tk.StringVar(value='ro')
        fr_lang = ttk.Frame(header)
        fr_lang.pack(side='right')
        ttk.Radiobutton(fr_lang, text="Romanian", variable=self.lang_var, value='ro', command=self.change_lang).pack(
            side='left', padx=5)
        ttk.Radiobutton(fr_lang, text="English", variable=self.lang_var, value='en', command=self.change_lang).pack(
            side='left', padx=5)

        self.notebook = ttk.Notebook(root)
        self.notebook.pack(fill='both', expand=True, padx=10, pady=5)
        self.tab_analyze = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_analyze, text="  Analyze & Audio  ")
        self.build_analyze_tab()
        self.tab_compare = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_compare, text="  Compare (A vs B)  ")
        self.build_compare_tab()
        self.tab_batch = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_batch, text="  Batch Processing  ")
        self.build_batch_tab()
        self.tab_history = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_history, text="  History / Database  ")
        self.build_history_tab()

    def change_lang(self):
        self.analyzer.set_language(self.lang_var.get())
        messagebox.showinfo("Info", "Analysis language changed.")

    def build_analyze_tab(self):
        paned = ttk.PanedWindow(self.tab_analyze, orient='horizontal')
        paned.pack(fill='both', expand=True, padx=10, pady=10)

        # --- LEFT PANEL ---
        left = ttk.Frame(paned)
        paned.add(left, weight=3)
        btn_frame = ttk.Frame(left)
        btn_frame.pack(fill='x', pady=5)
        ttk.Button(btn_frame, text="ðŸ“‚ Load Text", command=self.load_text).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="ðŸŽ¤ Audio (.wav)", command=self.load_audio).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="ðŸ§¹ Clear", command=lambda: self.txt_input.delete("1.0", tk.END)).pack(side='right')
        self.txt_input = scrolledtext.ScrolledText(left, height=20, font=("Segoe UI", 10))
        self.txt_input.pack(fill='both', expand=True)
        btn_run = tk.Button(left, text="ANALYZE", bg="#2980b9", fg="white", font=("Segoe UI", 11, "bold"), pady=8,
                            command=self.run_analysis)
        btn_run.pack(fill='x', pady=10)

        # --- RIGHT PANEL ---
        right = ttk.Frame(paned)
        paned.add(right, weight=2)

        fr_top_right = ttk.Frame(right)
        fr_top_right.pack(fill='x')
        self.lbl_case_id = ttk.Label(fr_top_right, text="CASE ID: -", font=("Courier", 12, "bold"),
                                     foreground="#2c3e50")
        self.lbl_case_id.pack(side='right')
        lbl_risk = ttk.Label(fr_top_right, text="Risk Meter:", font=("Segoe UI", 10, "bold"))
        lbl_risk.pack(side='left')

        self.progress = ttk.Progressbar(right, length=200, mode='determinate')
        self.progress.pack(fill='x', pady=5)
        self.lbl_score_val = ttk.Label(right, text="0 / 100", font=("Segoe UI", 16, "bold"), foreground="#7f8c8d")
        self.lbl_score_val.pack(pady=5)

        self.lbl_sentiment = tk.Label(right, text="SENTIMENT: -", bg="#bdc3c7", fg="white",
                                      font=("Segoe UI", 9, "bold"), width=30)
        self.lbl_sentiment.pack(pady=2)

        # Result Area
        self.txt_report = tk.Text(right, height=15, bg="#f8f9fa", font=("Consolas", 9), relief="flat", padx=5, pady=5)
        self.txt_report.pack(fill='both', expand=True, pady=5)
        self.txt_report.tag_config("title", foreground="#2c3e50", font=("Segoe UI", 10, "bold"))

        exp_frame = ttk.Frame(right)
        exp_frame.pack(fill='x', pady=5)
        ttk.Button(exp_frame, text="ðŸ’¾ Export HTML", command=self.save_html).pack(side='left', fill='x', expand=True,
                                                                                 padx=2)
        ttk.Button(exp_frame, text="ðŸ“„ Export PDF", command=self.save_pdf).pack(side='left', fill='x', expand=True,
                                                                               padx=2)

    def load_text(self):
        path = filedialog.askopenfilename(filetypes=[("Text", "*.txt")])
        if path:
            self.current_filename = os.path.basename(path)
            with open(path, "r", encoding="utf-8") as f:
                self.txt_input.delete("1.0", tk.END)
                self.txt_input.insert("1.0", f.read())

    def load_audio(self):
        path = filedialog.askopenfilename(filetypes=[("Audio", "*.wav")])
        if not path: return
        self.current_filename = os.path.basename(path) + " (Audio)"

        def task():
            self.txt_input.delete("1.0", tk.END)
            self.txt_input.insert("1.0", "[PROCESSING...]")
            text = self.analyzer.transcribe_audio(path)
            self.txt_input.delete("1.0", tk.END)
            self.txt_input.insert("1.0", text)

        threading.Thread(target=task).start()

    def run_analysis(self):
        text = self.txt_input.get("1.0", tk.END).strip()
        if not text: return
        m = self.analyzer.get_metrics(text)
        if not m: return
        self.last_metrics = m
        score = m['risk_score']
        verdict = self.analyzer.get_conclusion(score)
        new_id = self.db.save_analysis(self.current_filename, score, verdict, text)
        self.last_case_id = new_id
        self.refresh_history()

        formatted_id = f"LYAR-{str(new_id).zfill(5)}"
        self.lbl_case_id.config(text=f"CASE ID: {formatted_id}")
        self.progress['value'] = score
        color = "#27ae60"
        if score >= 40: color = "#f39c12"
        if score >= 70: color = "#c0392b"
        self.lbl_score_val.config(text=f"{score} / 100", foreground=color)

        sent = m['sentiment_label']
        sent_col = "#bdc3c7"
        if "POS" in sent or "POZ" in sent:
            sent_col = "#27ae60"
        elif "NEG" in sent:
            sent_col = "#c0392b"
        self.lbl_sentiment.config(text=f"{sent} ({m['sentiment_score']:.2f})", bg=sent_col)

        self.txt_report.config(state="normal")
        self.txt_report.delete("1.0", tk.END)
        self.txt_report.insert("end", f"=== REPORT ({self.analyzer.lang.upper()}) ===\n\n", "title")
        self.txt_report.insert("end", f"{verdict}\n")
        self.txt_report.insert("end", f"Total Words: {m['total_words']}\n\n")
        display_map = self.analyzer.ui['labels']
        keys = ['p_den', 'h_den', 'q_den', 't_den', 'f_den']
        for k in keys:
            val = m['densities'][k]
            self.txt_report.insert("end", f"{display_map.get(k, k):<20} {val:.2f}%\n")
        self.txt_report.config(state="disabled")

    def save_html(self):
        if not self.last_metrics: return
        path = filedialog.asksaveasfilename(defaultextension=".html")
        if path:
            self.analyzer.export_html(self.txt_input.get("1.0", tk.END), self.last_metrics, path, self.last_case_id)
            messagebox.showinfo("OK", "HTML Saved!")

    def save_pdf(self):
        if not self.last_metrics: return
        path = filedialog.asksaveasfilename(defaultextension=".pdf")
        if path:
            try:
                self.analyzer.export_pdf(self.txt_input.get("1.0", tk.END), self.last_metrics, path, self.last_case_id)
                messagebox.showinfo("OK", "PDF Saved!")
            except Exception as e:
                messagebox.showerror("Error", f"PDF Error: {e}")

    def build_compare_tab(self):
        fr = ttk.Frame(self.tab_compare, padding=20)
        fr.pack(fill='both', expand=True)
        fr_sel = ttk.LabelFrame(fr, text="Select Files", padding=10)
        fr_sel.pack(fill='x', pady=5)
        self.path_a = tk.StringVar()
        self.path_b = tk.StringVar()
        ttk.Button(fr_sel, text="File A", command=lambda: self.path_a.set(filedialog.askopenfilename())).grid(row=0,
                                                                                                              column=0,
                                                                                                              pady=5)
        ttk.Entry(fr_sel, textvariable=self.path_a, width=50).grid(row=0, column=1, padx=5)
        ttk.Button(fr_sel, text="File B", command=lambda: self.path_b.set(filedialog.askopenfilename())).grid(row=1,
                                                                                                              column=0,
                                                                                                              pady=5)
        ttk.Entry(fr_sel, textvariable=self.path_b, width=50).grid(row=1, column=1, padx=5)
        ttk.Button(fr, text="COMPARE", command=self.run_compare).pack(pady=15)
        self.txt_comp_res = tk.Text(fr, height=10, bg="#f8f9fa", font=("Segoe UI", 11), relief="flat", padx=10, pady=10)
        self.txt_comp_res.pack(fill='both', expand=True)

    def run_compare(self):
        p1, p2 = self.path_a.get(), self.path_b.get()
        if not p1 or not p2: return
        try:
            with open(p1, 'r', encoding='utf-8') as f:
                t1 = f.read()
            with open(p2, 'r', encoding='utf-8') as f:
                t2 = f.read()
            m1 = self.analyzer.get_metrics(t1)
            m2 = self.analyzer.get_metrics(t2)
            s1, s2 = m1['risk_score'], m2['risk_score']
            self.txt_comp_res.delete("1.0", tk.END)
            self.txt_comp_res.insert("end",
                                     f"A: Score {s1}\nB: Score {s2}\n\nVERDICT: {'Statement A' if s1 < s2 else 'Statement B'} is more credible.")
        except Exception as e:
            messagebox.showerror("Error", str(e))

    def build_batch_tab(self):
        fr = ttk.Frame(self.tab_batch, padding=20)
        fr.pack(fill='both', expand=True)
        top_fr = ttk.Frame(fr)
        top_fr.pack(fill='x')
        self.folder_path = tk.StringVar()
        ttk.Button(top_fr, text="Select Folder", command=lambda: self.folder_path.set(filedialog.askdirectory())).pack(
            side='left')
        ttk.Label(top_fr, textvariable=self.folder_path).pack(side='left', padx=10)
        ttk.Button(fr, text="PROCESS ALL", command=self.run_batch).pack(pady=10, fill='x')
        cols = ("rank", "filename", "score", "risk_level")
        self.tree_batch = ttk.Treeview(fr, columns=cols, show='headings', height=15)
        for c in cols: self.tree_batch.heading(c, text=c.capitalize())
        self.tree_batch.pack(fill='both', expand=True)

    def run_batch(self):
        folder = self.folder_path.get()
        if not folder: return

        def process():
            for i in self.tree_batch.get_children(): self.tree_batch.delete(i)
            all_res = []
            for f_name in os.listdir(folder):
                if f_name.endswith(".txt"):
                    with open(os.path.join(folder, f_name), 'r', encoding='utf-8') as f:
                        m = self.analyzer.get_metrics(f.read())
                        if m: all_res.append({'filename': f_name, 'risk': m['risk_score'],
                                              'lvl': self.analyzer.get_conclusion(m['risk_score'])})
            all_res.sort(key=lambda x: x['risk'], reverse=True)
            self.analyzer.generate_batch_chart(all_res, "batch_result.png")
            for idx, res in enumerate(all_res, 1):
                self.tree_batch.insert("", "end", values=(idx, res['filename'], res['risk'], res['lvl']))
            if os.name == 'nt': os.startfile("batch_result.png")

        threading.Thread(target=process).start()

    def build_history_tab(self):
        fr = ttk.Frame(self.tab_history, padding=20)
        fr.pack(fill='both', expand=True)
        search_fr = ttk.Frame(fr)
        search_fr.pack(fill='x', pady=5)
        ttk.Label(search_fr, text="Search:").pack(side='left')
        self.search_var = tk.StringVar()
        ttk.Entry(search_fr, textvariable=self.search_var, width=40).pack(side='left', padx=10)
        ttk.Button(search_fr, text="ðŸ”Ž Search", command=self.search_history).pack(side='left')
        ttk.Button(search_fr, text="ðŸ”„ Reload", command=self.refresh_history).pack(side='left', padx=5)
        btn_fr = ttk.Frame(fr)
        btn_fr.pack(fill='x', pady=5)
        ttk.Button(btn_fr, text="ðŸ—‘ Delete Selected", command=self.delete_history_item).pack(side='right', padx=5)
        ttk.Button(btn_fr, text="âš  Delete ALL", command=self.clear_all_history).pack(side='right', padx=5)
        ttk.Button(btn_fr, text="ðŸ“„ Re-Export PDF", command=lambda: self.export_from_history('pdf')).pack(side='right',
                                                                                                         padx=5)
        ttk.Button(btn_fr, text="ðŸ’¾ Re-Export HTML", command=lambda: self.export_from_history('html')).pack(side='right',
                                                                                                           padx=5)
        cols = ("id", "date", "file", "score", "verdict", "preview")
        self.tree_hist = ttk.Treeview(fr, columns=cols, show='headings', height=20)
        self.tree_hist.heading("id", text="ID")
        self.tree_hist.heading("date", text="Date/Time")
        self.tree_hist.heading("file", text="Filename")
        self.tree_hist.heading("score", text="Score")
        self.tree_hist.heading("verdict", text="Verdict")
        self.tree_hist.heading("preview", text="Preview")
        self.tree_hist.column("id", width=30, anchor="center")
        self.tree_hist.column("date", width=120, anchor="center")
        self.tree_hist.column("file", width=150)
        self.tree_hist.column("score", width=50, anchor="center")
        self.tree_hist.column("verdict", width=100, anchor="center")
        self.tree_hist.column("preview", width=400)
        vsb = ttk.Scrollbar(fr, orient="vertical", command=self.tree_hist.yview)
        self.tree_hist.configure(yscrollcommand=vsb.set)
        self.tree_hist.pack(side='left', fill='both', expand=True)
        vsb.pack(side='right', fill='y')
        self.refresh_history()

    def refresh_history(self):
        for i in self.tree_hist.get_children(): self.tree_hist.delete(i)
        rows = self.db.get_all()
        for r in rows: self.tree_hist.insert("", "end", values=r)

    def search_history(self):
        query = self.search_var.get()
        if not query:
            self.refresh_history()
            return
        for i in self.tree_hist.get_children(): self.tree_hist.delete(i)
        rows = self.db.search(query)
        for r in rows: self.tree_hist.insert("", "end", values=r)

    def delete_history_item(self):
        selected = self.tree_hist.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a row.")
            return
        if messagebox.askyesno("Confirm", "Are you sure you want to delete the selection?"):
            for item in selected:
                vals = self.tree_hist.item(item)['values']
                self.db.delete_entry(vals[0])
            self.refresh_history()

    def clear_all_history(self):
        if messagebox.askyesno("Confirm",
                               "WARNING: This will delete the ENTIRE history and reset the Case ID to 1. Continue?"):
            self.db.clear_all()
            self.refresh_history()
            messagebox.showinfo("Info", "History cleared. Case ID counter reset.")

    def export_from_history(self, format_type):
        selected = self.tree_hist.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select an analysis from the table.")
            return
        item = selected[0]
        vals = self.tree_hist.item(item)['values']
        entry_id = vals[0]
        data = self.db.get_entry_details(entry_id)
        if not data: return
        full_text, filename_orig, _, _ = data
        metrics = self.analyzer.get_metrics(full_text)
        if format_type == 'html':
            path = filedialog.asksaveasfilename(defaultextension=".html", initialfile=f"Export_{entry_id}.html")
            if path:
                self.analyzer.export_html(full_text, metrics, path, entry_id)
                messagebox.showinfo("Success", "HTML Exported from History!")
        else:
            path = filedialog.asksaveasfilename(defaultextension=".pdf", initialfile=f"Export_{entry_id}.pdf")
            if path:
                try:
                    self.analyzer.export_pdf(full_text, metrics, path, entry_id)
                    messagebox.showinfo("Success", "PDF Exported from History!")
                except Exception as e:
                    messagebox.showerror("Error", str(e))


if __name__ == "__main__":
    root = tk.Tk()
    app = ForensicApp(root)
    root.mainloop()
